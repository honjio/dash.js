{"version":3,"sources":["../../../../../src/streaming/controllers/AbrController.js"],"names":["DEFAULT_VIDEO_BITRATE","DEFAULT_AUDIO_BITRATE","QUALITY_DEFAULT","AbrController","context","debug","getInstance","eventBus","instance","logger","abrRulesCollection","streamController","topQualities","qualityDict","streamProcessorDict","abandonmentStateDict","abandonmentTimeout","windowResizeEventCalled","elementWidth","elementHeight","adapter","videoModel","mediaPlayerModel","domStorage","playbackIndex","switchHistoryDict","droppedFramesHistory","throughputHistory","isUsingBufferOccupancyABRDict","isUsingL2AABRDict","dashMetrics","settings","setup","getLogger","resetInitialSettings","registerStreamType","type","streamProcessor","create","state","MetricsConstants","ALLOW_LOAD","on","Events","LOADING_PROGRESS","onFragmentLoadProgress","Constants","VIDEO","QUALITY_CHANGE_RENDERED","onQualityChangeRendered","setElementSize","METRIC_ADDED","onMetricAdded","PERIOD_SWITCH_COMPLETED","createAbrRulesCollection","unRegisterStreamType","initialize","undefined","clearTimeout","reset","off","setConfig","config","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","e","mediaType","oldQuality","push","getPlaybackQuality","metric","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","AUDIO","get","streaming","abr","useDeadTimeLatency","BUFFER_LEVEL","_updateAbrStrategy","level","getTopQualityIndexFor","id","idx","checkMaxBitrate","checkMaxRepresentationRatio","checkPortalSize","getTopBitrateInfoFor","streamInfo","getStreamInfo","bitrates","getBitrateList","getMediaInfo","getInitialBitrateFor","TEXT","FRAGMENTED_TEXT","NaN","savedBitrate","getSavedBitrateSettings","configBitrate","initialBitrate","configRatio","initialRepresentationRatio","representation","getAdaptationForType","Representation","Array","isArray","repIdx","Math","max","round","length","bandwidth","isNaN","getMaxAllowedBitrateFor","maxBitrate","getMinAllowedBitrateFor","minBitrate","getMaxAllowedIndexFor","getQualityForBitrate","getMinAllowedIndexFor","mediaInfo","bitrateList","minIdx","bitrate","checkPlaybackQuality","streamId","getQualityFor","rulesContext","abrController","currentValue","switchHistory","useBufferOccupancyABR","useL2AABR","playbackQuality","autoSwitchBitrate","topQualityIdx","switchRequest","getMaxQuality","newQuality","quality","SwitchRequest","NO_CHANGE","oldValue","newValue","changeQuality","reason","logLevel","Debug","LOG_LEVEL_DEBUG","bufferLevel","getCurrentBufferLevel","setPlaybackQuality","info","JSON","stringify","setQualityFor","trigger","QUALITY_CHANGE_REQUESTED","getAverageThroughput","setSavedBitrateSettings","setAbandonmentStateFor","getAbandonmentStateFor","latency","voRepresentation","getRepresentationInfo","fragmentDuration","deadTimeRatio","i","bitrateInfo","infoList","ln","BitrateInfo","qualityIndex","width","height","scanType","strategy","ABRStrategy","ABR_STRATEGY_L2A","ABR_STRATEGY_BOLA","ABR_STRATEGY_THROUGHPUT","_updateDynamicAbrStrategy","stableBufferTime","getStableBufferTime","switchOnThreshold","switchOffThreshold","useBufferABR","newUseBufferABR","toFixed","getThroughputHistory","updateTopQualityIndex","representationCount","setTopQualityIndex","isPlayingAtTopQuality","audioQuality","videoQuality","isAtTop","newIdx","maxIdx","min","maxRepresentationRatio","setWindowResizeEventCalled","hasPixelRatio","usePixelRatioInLimitBitrateByPortal","window","pixelRatio","devicePixelRatio","getClientWidth","getClientHeight","limitBitrateByPortal","request","currentRequest","shouldAbandonFragment","fragmentModel","getFragmentModel","getRequests","FragmentModel","FRAGMENT_MODEL_LOADING","index","abortRequests","ABANDON_LOAD","confidence","getActiveStreamInfo","setTimeout","abandonLoadTimeout","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"AbrController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport ABRRulesCollection from '../rules/abr/ABRRulesCollection';\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BitrateInfo from '../vo/BitrateInfo';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport RulesContext from '../rules/RulesContext';\nimport SwitchRequest from '../rules/SwitchRequest';\nimport SwitchRequestHistory from '../rules/SwitchRequestHistory';\nimport DroppedFramesHistory from '../rules/DroppedFramesHistory';\nimport ThroughputHistory from '../rules/ThroughputHistory';\nimport Debug from '../../core/Debug';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport { checkInteger } from '../utils/SupervisorTools';\n\nconst DEFAULT_VIDEO_BITRATE = 1000;\nconst DEFAULT_AUDIO_BITRATE = 100;\nconst QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n\n    const context = this.context;\n    const debug = Debug(context).getInstance();\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        abrRulesCollection,\n        streamController,\n        topQualities,\n        qualityDict,\n        streamProcessorDict,\n        abandonmentStateDict,\n        abandonmentTimeout,\n        windowResizeEventCalled,\n        elementWidth,\n        elementHeight,\n        adapter,\n        videoModel,\n        mediaPlayerModel,\n        domStorage,\n        playbackIndex,\n        switchHistoryDict,\n        droppedFramesHistory,\n        throughputHistory,\n        isUsingBufferOccupancyABRDict,\n        isUsingL2AABRDict,\n        dashMetrics,\n        settings;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function registerStreamType(type, streamProcessor) {\n        switchHistoryDict[type] = switchHistoryDict[type] || SwitchRequestHistory(context).create();\n        streamProcessorDict[type] = streamProcessor;\n        abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n        abandonmentStateDict[type].state = MetricsConstants.ALLOW_LOAD;\n        isUsingBufferOccupancyABRDict[type] = false;\n        isUsingL2AABRDict[type] = false;\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        if (type === Constants.VIDEO) {\n            eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n            droppedFramesHistory = droppedFramesHistory || DroppedFramesHistory(context).create();\n            setElementSize();\n        }\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        throughputHistory = throughputHistory || ThroughputHistory(context).create({\n            settings: settings\n        });\n    }\n\n    function unRegisterStreamType(type) {\n        delete streamProcessorDict[type];\n    }\n\n    function createAbrRulesCollection() {\n        abrRulesCollection = ABRRulesCollection(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n        });\n\n        abrRulesCollection.initialize();\n    }\n\n    function resetInitialSettings() {\n        topQualities = {};\n        qualityDict = {};\n        abandonmentStateDict = {};\n        streamProcessorDict = {};\n        switchHistoryDict = {};\n        isUsingBufferOccupancyABRDict = {};\n        isUsingL2AABRDict = {};\n        if (windowResizeEventCalled === undefined) {\n            windowResizeEventCalled = false;\n        }\n        playbackIndex = undefined;\n        droppedFramesHistory = undefined;\n        throughputHistory = undefined;\n        clearTimeout(abandonmentTimeout);\n        abandonmentTimeout = null;\n    }\n\n    function reset() {\n\n        resetInitialSettings();\n\n        eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, instance);\n        eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, instance);\n\n        if (abrRulesCollection) {\n            abrRulesCollection.reset();\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function checkConfig() {\n        if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function onQualityChangeRendered(e) {\n        if (e.mediaType === Constants.VIDEO) {\n            playbackIndex = e.oldQuality;\n            droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n        }\n\n        if (e.metric === MetricsConstants.BUFFER_LEVEL && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            _updateAbrStrategy(e.mediaType, 0.001 * e.value.level);\n        }\n    }\n\n    function getTopQualityIndexFor(type, id) {\n        let idx;\n        topQualities[id] = topQualities[id] || {};\n\n        if (!topQualities[id].hasOwnProperty(type)) {\n            topQualities[id][type] = 0;\n        }\n\n        idx = checkMaxBitrate(topQualities[id][type], type);\n        idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n        idx = checkPortalSize(idx, type);\n        return idx;\n    }\n\n    /**\n     * Gets top BitrateInfo for the player\n     * @param {string} type - 'video' or 'audio' are the type options.\n     * @returns {BitrateInfo | null}\n     */\n    function getTopBitrateInfoFor(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            if (streamInfo && streamInfo.id) {\n                const idx = getTopQualityIndexFor(type, streamInfo.id);\n                const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n                return bitrates[idx] ? bitrates[idx] : null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {number} A value of the initial bitrate, kbps\n     * @memberof AbrController#\n     */\n    function getInitialBitrateFor(type) {\n        checkConfig();\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT) {\n            return NaN;\n        }\n        const savedBitrate = domStorage.getSavedBitrateSettings(type);\n        let configBitrate = settings.get().streaming.abr.initialBitrate[type];\n        let configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n        if (configBitrate === -1) {\n            if (configRatio > -1) {\n                const representation = adapter.getAdaptationForType(0, type).Representation;\n                if (Array.isArray(representation)) {\n                    const repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n                    configBitrate = representation[repIdx].bandwidth;\n                } else {\n                    configBitrate = 0;\n                }\n            } else if (!isNaN(savedBitrate)) {\n                configBitrate = savedBitrate;\n            } else {\n                configBitrate = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n            }\n        }\n\n        return configBitrate;\n    }\n\n    function getMaxAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.maxBitrate[type];\n    }\n\n    function getMinAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.minBitrate[type];\n    }\n\n    function getMaxAllowedIndexFor(type) {\n        const maxBitrate = getMaxAllowedBitrateFor(type);\n        if (maxBitrate > -1) {\n            return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n        } else {\n            return undefined;\n        }\n    }\n\n    function getMinAllowedIndexFor(type) {\n        const minBitrate = getMinAllowedBitrateFor(type);\n\n        if (minBitrate > -1) {\n            const mediaInfo = streamProcessorDict[type].getMediaInfo();\n            const bitrateList = getBitrateList(mediaInfo);\n            // This returns the quality index <= for the given bitrate\n            let minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n            if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n                minIdx++; // Go to the next bitrate\n            }\n            return minIdx;\n        } else {\n            return undefined;\n        }\n    }\n\n    function checkPlaybackQuality(type) {\n        if (type && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const streamId = streamInfo ? streamInfo.id : null;\n            const oldQuality = getQualityFor(type);\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessorDict[type],\n                currentValue: oldQuality,\n                switchHistory: switchHistoryDict[type],\n                droppedFramesHistory: droppedFramesHistory,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type)\n\n            });\n\n            if (droppedFramesHistory) {\n                const playbackQuality = videoModel.getPlaybackQuality();\n                if (playbackQuality) {\n                    droppedFramesHistory.push(playbackIndex, playbackQuality);\n                }\n            }\n            if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n                const minIdx = getMinAllowedIndexFor(type);\n                const topQualityIdx = getTopQualityIndexFor(type, streamId);\n                const switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n                let newQuality = switchRequest.quality;\n                if (minIdx !== undefined && ((newQuality > SwitchRequest.NO_CHANGE) ? newQuality : oldQuality) < minIdx) {\n                    newQuality = minIdx;\n                }\n                if (newQuality > topQualityIdx) {\n                    newQuality = topQualityIdx;\n                }\n\n                switchHistoryDict[type].push({oldValue: oldQuality, newValue: newQuality});\n\n                if (newQuality > SwitchRequest.NO_CHANGE && newQuality != oldQuality) {\n                    if (abandonmentStateDict[type].state === MetricsConstants.ALLOW_LOAD || newQuality > oldQuality) {\n                        changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n                    }\n                } else if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                    const bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n                    logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n                }\n            }\n        }\n    }\n\n    function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n        const id = streamInfo.id;\n        const oldQuality = getQualityFor(type);\n\n        checkInteger(newQuality);\n\n        const topQualityIdx = getTopQualityIndexFor(type, id);\n        if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n        }\n    }\n\n    function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(type);\n                logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n            }\n            setQualityFor(type, id, newQuality);\n            eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED,\n                {\n                    oldQuality: oldQuality,\n                    newQuality: newQuality,\n                    reason: reason\n                },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n            const bitrate = throughputHistory.getAverageThroughput(type);\n            if (!isNaN(bitrate)) {\n                domStorage.setSavedBitrateSettings(type, bitrate);\n            }\n        }\n    }\n\n    function setAbandonmentStateFor(type, state) {\n        abandonmentStateDict[type].state = state;\n    }\n\n    function getAbandonmentStateFor(type) {\n        return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @param {number} bitrate A bitrate value, kbps\n     * @param {number} latency Expected latency of connection, ms\n     * @returns {number} A quality index <= for the given bitrate\n     * @memberof AbrController#\n     */\n    function getQualityForBitrate(mediaInfo, bitrate, latency) {\n        const voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n        if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n            latency = latency / 1000;\n            const fragmentDuration = voRepresentation.fragmentDuration;\n            if (latency > fragmentDuration) {\n                return 0;\n            } else {\n                const deadTimeRatio = latency / fragmentDuration;\n                bitrate = bitrate * (1 - deadTimeRatio);\n            }\n        }\n\n        const bitrateList = getBitrateList(mediaInfo);\n\n        for (let i = bitrateList.length - 1; i >= 0; i--) {\n            const bitrateInfo = bitrateList[i];\n            if (bitrate * 1000 >= bitrateInfo.bitrate) {\n                return i;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @returns {Array|null} A list of {@link BitrateInfo} objects\n     * @memberof AbrController#\n     */\n    function getBitrateList(mediaInfo) {\n        const infoList = [];\n        if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n\n        const bitrateList = mediaInfo.bitrateList;\n        const type = mediaInfo.type;\n\n        let bitrateInfo;\n\n        for (let i = 0, ln = bitrateList.length; i < ln; i++) {\n            bitrateInfo = new BitrateInfo();\n            bitrateInfo.mediaType = type;\n            bitrateInfo.qualityIndex = i;\n            bitrateInfo.bitrate = bitrateList[i].bandwidth;\n            bitrateInfo.width = bitrateList[i].width;\n            bitrateInfo.height = bitrateList[i].height;\n            bitrateInfo.scanType = bitrateList[i].scanType;\n            infoList.push(bitrateInfo);\n        }\n\n        return infoList;\n    }\n\n    function _updateAbrStrategy(mediaType, bufferLevel) {\n        const strategy = settings.get().streaming.abr.ABRStrategy;\n\n        if (strategy === Constants.ABR_STRATEGY_L2A) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = true;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_BOLA) {\n            isUsingBufferOccupancyABRDict[mediaType] = true;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            isUsingL2AABRDict[mediaType] = false;\n            return;\n        }\n        // else ABR_STRATEGY_DYNAMIC\n        _updateDynamicAbrStrategy(mediaType, bufferLevel);\n    }\n\n    function _updateDynamicAbrStrategy(mediaType, bufferLevel) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const switchOnThreshold = stableBufferTime;\n        const switchOffThreshold = 0.5 * stableBufferTime;\n\n        const useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n        const newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n        isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n        if (newUseBufferABR !== useBufferABR) {\n            if (newUseBufferABR) {\n                logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            } else {\n                logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            }\n        }\n    }\n\n    function useBufferOccupancyABR(mediaType) {\n        return isUsingBufferOccupancyABRDict[mediaType];\n    }\n\n    function useL2AABR(mediaType) {\n        return isUsingL2AABRDict[mediaType];\n    }\n\n    function getThroughputHistory() {\n        return throughputHistory;\n    }\n\n    function updateTopQualityIndex(mediaInfo) {\n        const type = mediaInfo.type;\n        const streamId = mediaInfo.streamInfo.id;\n        const max = mediaInfo.representationCount - 1;\n\n        setTopQualityIndex(type, streamId, max);\n\n        return max;\n    }\n\n    function isPlayingAtTopQuality(streamInfo) {\n        const streamId = streamInfo ? streamInfo.id : null;\n        const audioQuality = getQualityFor(Constants.AUDIO);\n        const videoQuality = getQualityFor(Constants.VIDEO);\n\n        const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &&\n            (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId));\n\n        return isAtTop;\n    }\n\n    function getQualityFor(type) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            let quality;\n\n            if (id) {\n                qualityDict[id] = qualityDict[id] || {};\n\n                if (!qualityDict[id].hasOwnProperty(type)) {\n                    qualityDict[id][type] = QUALITY_DEFAULT;\n                }\n\n                quality = qualityDict[id][type];\n                return quality;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    function setQualityFor(type, id, value) {\n        qualityDict[id] = qualityDict[id] || {};\n        qualityDict[id][type] = value;\n    }\n\n    function setTopQualityIndex(type, id, value) {\n        topQualities[id] = topQualities[id] || {};\n        topQualities[id][type] = value;\n    }\n\n    function checkMaxBitrate(idx, type) {\n        let newIdx = idx;\n\n        if (!streamProcessorDict[type]) {\n            return newIdx;\n        }\n\n        const minIdx = getMinAllowedIndexFor(type);\n        if (minIdx !== undefined) {\n            newIdx = Math.max(idx, minIdx);\n        }\n\n        const maxIdx = getMaxAllowedIndexFor(type);\n        if (maxIdx !== undefined) {\n            newIdx = Math.min(newIdx, maxIdx);\n        }\n\n        return newIdx;\n    }\n\n    function checkMaxRepresentationRatio(idx, type, maxIdx) {\n        const maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n        if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n            return idx;\n        }\n        return Math.min(idx, Math.round(maxIdx * maxRepresentationRatio));\n    }\n\n    function setWindowResizeEventCalled(value) {\n        windowResizeEventCalled = value;\n    }\n\n    function setElementSize() {\n        if (videoModel) {\n            const hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n            const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n            elementWidth = videoModel.getClientWidth() * pixelRatio;\n            elementHeight = videoModel.getClientHeight() * pixelRatio;\n        }\n    }\n\n    function checkPortalSize(idx, type) {\n        if (type !== Constants.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n            return idx;\n        }\n\n        if (!windowResizeEventCalled) {\n            setElementSize();\n        }\n\n        const representation = adapter.getAdaptationForType(0, type).Representation;\n        let newIdx = idx;\n\n        if (elementWidth > 0 && elementHeight > 0) {\n            while (\n                newIdx > 0 &&\n                representation[newIdx] &&\n                elementWidth < representation[newIdx].width &&\n                elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n                newIdx = newIdx - 1;\n            }\n\n            // Make sure that in case of multiple representation elements have same\n            // resolution, every such element is included\n            while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n                newIdx = newIdx + 1;\n            }\n        }\n\n        return newIdx;\n    }\n\n    function onFragmentLoadProgress(e) {\n        const type = e.request.mediaType;\n        if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n            const streamProcessor = streamProcessorDict[type];\n            if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessor,\n                currentRequest: e.request,\n                useBufferOccupancyABR: useBufferOccupancyABR(type),\n                useL2AABR: useL2AABR(type)\n            });\n            const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n            if (switchRequest.quality > SwitchRequest.NO_CHANGE) {\n                const fragmentModel = streamProcessor.getFragmentModel();\n                const request = fragmentModel.getRequests({\n                    state: FragmentModel.FRAGMENT_MODEL_LOADING,\n                    index: e.request.index\n                })[0];\n                if (request) {\n                    //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n                    fragmentModel.abortRequests();\n                    setAbandonmentStateFor(type, MetricsConstants.ABANDON_LOAD);\n                    switchHistoryDict[type].reset();\n                    switchHistoryDict[type].push({\n                        oldValue: getQualityFor(type),\n                        newValue: switchRequest.quality,\n                        confidence: 1,\n                        reason: switchRequest.reason\n                    });\n                    setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n\n                    clearTimeout(abandonmentTimeout);\n                    abandonmentTimeout = setTimeout(\n                        () => {\n                            setAbandonmentStateFor(type, MetricsConstants.ALLOW_LOAD);\n                            abandonmentTimeout = null;\n                        },\n                        settings.get().streaming.abandonLoadTimeout\n                    );\n                }\n            }\n        }\n    }\n\n    instance = {\n        isPlayingAtTopQuality: isPlayingAtTopQuality,\n        updateTopQualityIndex: updateTopQualityIndex,\n        getThroughputHistory: getThroughputHistory,\n        getBitrateList: getBitrateList,\n        getQualityForBitrate: getQualityForBitrate,\n        getTopBitrateInfoFor: getTopBitrateInfoFor,\n        getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n        getMinAllowedIndexFor: getMinAllowedIndexFor,\n        getInitialBitrateFor: getInitialBitrateFor,\n        getQualityFor: getQualityFor,\n        getAbandonmentStateFor: getAbandonmentStateFor,\n        setPlaybackQuality: setPlaybackQuality,\n        checkPlaybackQuality: checkPlaybackQuality,\n        getTopQualityIndexFor: getTopQualityIndexFor,\n        setElementSize: setElementSize,\n        setWindowResizeEventCalled: setWindowResizeEventCalled,\n        createAbrRulesCollection: createAbrRulesCollection,\n        registerStreamType: registerStreamType,\n        unRegisterStreamType: unRegisterStreamType,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\nconst factory = FactoryMaker.getSingletonFactory(AbrController);\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\nFactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\nexport default factory;\n"]}