{"version":3,"sources":["../../../../../src/streaming/controllers/EventController.js"],"names":["EventController","MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REFRESH_DELAY","REMAINING_EVENTS_THRESHOLD","context","eventBus","getInstance","instance","logger","inlineEvents","inbandEvents","activeEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","eventHandlingInProgress","isStarted","setup","getLogger","_resetInitialSettings","checkConfig","Error","Date","now","_stop","clearInterval","_onStopEventController","e","start","debug","isNaN","setInterval","_onEventTimer","addInlineEvents","values","i","length","event","id","_startEvent","EVENT_MODE_ON_RECEIVE","addInbandEvents","eventStream","schemeIdUri","undefined","_handleManifestReloadEvent","value","timescale","validUntil","calculatedPresentationTime","newDuration","NaN","duration","info","trigger","Events","MANIFEST_VALIDITY_CHANGED","newManifestValidAfter","mode","EVENT_MODE_ON_START","_removeEvents","currentVideoTime","getTime","eventIds","Object","keys","eventId","presentationTimeThreshold","Math","max","_triggerEvents","_triggerRemainingEvents","events","calculatedPresentationTimeInSeconds","_eventHasExpired","_eventIsInvalid","periodEndTime","period","currentTime","periodDuration","periodStart","forEach","abs","presentationTimeDelta","_refreshManifest","_sendCallbackRequest","messageData","refreshManifest","url","loader","create","load","method","request","responseType","setConfig","config","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"EventController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport XHRLoader from '../net/XHRLoader';\nimport {EVENT_MODE_ON_START, EVENT_MODE_ON_RECEIVE} from '../MediaPlayerEvents';\n\nfunction EventController() {\n\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n    const MPD_RELOAD_VALUE = 1;\n\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n    const MPD_CALLBACK_VALUE = 1;\n\n    const REFRESH_DELAY = 100;\n    const REMAINING_EVENTS_THRESHOLD = 300;\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        inlineEvents, // Holds all Inline Events not triggered yet\n        inbandEvents, // Holds all Inband Events not triggered yet\n        activeEvents, // Holds all Events currently running\n        eventInterval, // variable holding the setInterval\n        lastEventTimerCall,\n        manifestUpdater,\n        playbackController,\n        eventHandlingInProgress,\n        isStarted;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    function checkConfig() {\n        if (!manifestUpdater || !playbackController) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function _resetInitialSettings() {\n        isStarted = false;\n        inlineEvents = {};\n        inbandEvents = {};\n        activeEvents = {};\n        eventInterval = null;\n        eventHandlingInProgress = false;\n        lastEventTimerCall = Date.now() / 1000;\n    }\n\n    function _stop() {\n        try {\n            if (eventInterval !== null && isStarted) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n                isStarted = false;\n                _onStopEventController();\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function start() {\n        try {\n            checkConfig();\n            logger.debug('Start Event Controller');\n            if (!isStarted && !isNaN(REFRESH_DELAY)) {\n                isStarted = true;\n                eventInterval = setInterval(_onEventTimer, REFRESH_DELAY);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted\n     * @param {Array.<Object>} values\n     */\n    function addInlineEvents(values) {\n        try {\n            checkConfig();\n\n            if (values) {\n                for (let i = 0; i < values.length; i++) {\n                    let event = values[i];\n                    inlineEvents[event.id] = event;\n                    logger.debug('Add inline event with id ' + event.id);\n                    _startEvent(event.id, event, values, EVENT_MODE_ON_RECEIVE);\n                }\n            }\n            logger.debug(`Added ${values.length} inline events`);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * i.e. processing of any one event message box with the same id is sufficient\n     * @param {Array.<Object>} values\n     */\n    function addInbandEvents(values) {\n        try {\n            checkConfig();\n\n            for (let i = 0; i < values.length; i++) {\n                let event = values[i];\n                if (!(event.id in inbandEvents)) {\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n                        _handleManifestReloadEvent(event);\n                    }\n                    inbandEvents[event.id] = event;\n                    logger.debug('Add inband event with id ' + event.id);\n                    _startEvent(event.id, event, values, EVENT_MODE_ON_RECEIVE);\n                } else {\n                    logger.debug('Repeated event with id ' + event.id);\n                }\n            }\n            _onEventTimer();\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function _handleManifestReloadEvent(event) {\n        try {\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\n                const timescale = event.eventStream.timescale || 1;\n                const validUntil = event.calculatedPresentationTime / timescale;\n                let newDuration;\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\n                    newDuration = NaN;\n                } else {\n                    newDuration = (event.calculatedPresentationTime + event.duration) / timescale;\n                }\n                logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n                eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, {\n                    id: event.id,\n                    validUntil: validUntil,\n                    newDuration: newDuration,\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n                }, {\n                    mode: EVENT_MODE_ON_START\n                });\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Remove expired events from the list\n     */\n    function _removeEvents() {\n        try {\n            if (activeEvents) {\n                let currentVideoTime = playbackController.getTime();\n                let eventIds = Object.keys(activeEvents);\n\n                for (let i = 0; i < eventIds.length; i++) {\n                    let eventId = eventIds[i];\n                    let event = activeEvents[eventId];\n                    if (event !== null && (event.duration + event.calculatedPresentationTime) / event.eventStream.timescale < currentVideoTime) {\n                        logger.debug('Remove Event ' + eventId + ' at time ' + currentVideoTime);\n                        event = null;\n                        delete activeEvents[eventId];\n                    }\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Iterate through the eventList and trigger/remove the events\n     */\n    function _onEventTimer() {\n        try {\n            if (!eventHandlingInProgress) {\n                eventHandlingInProgress = true;\n                const currentVideoTime = playbackController.getTime();\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\n\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n                _removeEvents();\n\n                lastEventTimerCall = currentVideoTime;\n                eventHandlingInProgress = false;\n            }\n        } catch (e) {\n            eventHandlingInProgress = false;\n        }\n    }\n\n    function _onStopEventController() {\n        try {\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n            _triggerRemainingEvents(inbandEvents);\n            _triggerRemainingEvents(inlineEvents);\n        } catch (e) {\n\n        }\n    }\n\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n        try {\n            if (events) {\n                let eventIds = Object.keys(events);\n\n                for (let i = 0; i < eventIds.length; i++) {\n                    let eventId = eventIds[i];\n                    let event = events[eventId];\n\n                    if (event !== undefined) {\n                        const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime / event.eventStream.timescale;\n\n                        if (calculatedPresentationTimeInSeconds <= currentVideoTime && calculatedPresentationTimeInSeconds + presentationTimeThreshold >= currentVideoTime) {\n                            _startEvent(eventId, event, events, EVENT_MODE_ON_START);\n                        } else if (_eventHasExpired(currentVideoTime, presentationTimeThreshold, calculatedPresentationTimeInSeconds) || _eventIsInvalid(event)) {\n                            logger.debug(`Deleting event ${eventId} as it is expired or invalid`);\n                            delete events[eventId];\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n        }\n    }\n\n    function _eventHasExpired(currentVideoTime, presentationTimeThreshold, calculatedPresentationTimeInSeconds) {\n        try {\n            return currentVideoTime - presentationTimeThreshold > calculatedPresentationTimeInSeconds;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _eventIsInvalid(event) {\n        try {\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n\n            return event.calculatedPresentationTime / 1000 > periodEndTime;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function _triggerRemainingEvents(events) {\n        try {\n            const eventIds = Object.keys(events);\n            const currentTime = playbackController.getTime();\n\n            if (!eventIds || eventIds.length === 0) {\n                return;\n            }\n\n            const periodDuration = events[eventIds[0]].eventStream && events[eventIds[0]].eventStream.period && !isNaN(events[eventIds[0]].eventStream.period.duration) ? events[eventIds[0]].eventStream.period.duration : NaN;\n            const periodStart = events[eventIds[0]].eventStream && events[eventIds[0]].eventStream.period && !isNaN(events[eventIds[0]].eventStream.period.start) ? events[eventIds[0]].eventStream.period.start : NaN;\n\n            if (isNaN(periodDuration) || isNaN(periodStart)) {\n                return;\n            }\n\n            eventIds.forEach((eventId) => {\n                const event = events[eventId];\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime / event.eventStream.timescale;\n\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n                    _startEvent(eventId, event, events, EVENT_MODE_ON_START);\n                }\n            });\n        } catch (e) {\n\n        }\n    }\n\n    function _startEvent(eventId, event, events, mode) {\n        try {\n            const currentVideoTime = playbackController.getTime();\n\n            if (mode === EVENT_MODE_ON_RECEIVE) {\n                logger.debug(`Received event ${eventId}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n                return;\n            }\n\n            if (event.duration > 0) {\n                activeEvents[eventId] = event;\n            }\n\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\n                    _refreshManifest();\n                }\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\n                _sendCallbackRequest(event.messageData);\n            } else {\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n            }\n\n            delete events[eventId];\n\n        } catch (e) {\n        }\n    }\n\n    function _refreshManifest() {\n        try {\n            checkConfig();\n            manifestUpdater.refreshManifest();\n        } catch (e) {\n        }\n    }\n\n    function _sendCallbackRequest(url) {\n        try {\n            let loader = XHRLoader(context).create({});\n            loader.load({\n                method: 'get',\n                url: url,\n                request: {\n                    responseType: 'arraybuffer'\n                }\n            });\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function setConfig(config) {\n        try {\n            if (!config) {\n                return;\n            }\n\n            if (config.manifestUpdater) {\n                manifestUpdater = config.manifestUpdater;\n            }\n\n            if (config.playbackController) {\n                playbackController = config.playbackController;\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    function reset() {\n        _stop();\n        _resetInitialSettings();\n    }\n\n    instance = {\n        addInlineEvents,\n        addInbandEvents,\n        start,\n        setConfig,\n        reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nEventController.__dashjs_factory_name = 'EventController';\nexport default FactoryMaker.getSingletonFactory(EventController);\n"]}