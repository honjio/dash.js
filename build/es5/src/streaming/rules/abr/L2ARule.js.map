{"version":3,"sources":["../../../../../../src/streaming/rules/abr/L2ARule.js"],"names":["L2A_STATE_ONE_BITRATE","L2A_STATE_STARTUP","L2A_STATE_STEADY","L2ARule","config","context","dashMetrics","eventBus","getInstance","instance","l2AStateDict","l2AParameterDict","logger","setup","getLogger","_resetInitialSettings","on","Events","PLAYBACK_SEEKING","_onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","_onMediaFragmentLoaded","METRIC_ADDED","_onMetricAdded","QUALITY_CHANGE_REQUESTED","_onQualityChangeRequested","_getInitialL2AState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrates","bitrateList","map","b","bandwidth","state","lastQuality","_initializeL2AParameters","_clearL2AStateOnSeek","type","w","prev_w","Q","segment_request_start_s","segment_download_finish_s","B_target","l2AState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","_getL2AState","mediaType","getMediaType","hasOwnProperty","l2aState","e","chunk","l2AParameters","start","isNaN","duration","quality","_checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","length","trequest","getTime","_tfinish","L2AState","abrQuality","newQuality","_indexOfMin","arr","min","minIndex","i","_dotmultiplication","arr1","arr2","sumdot","euclideanProjection","m","bget","ii","s","sort","a","tmpsum","tmax","x","Math","max","getMaxIndex","switchRequest","create","horizon","vl","pow","alpha","sqrt","bitrateCount","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","isDynamic","manifestInfo","useL2AABR","bufferLevel","getCurrentBufferLevel","safeThroughput","getSafeAverageThroughput","throughput","getAverageThroughput","cThroughput","react","latency","getAverageLatency","reason","setTimeToLoadDelay","l2AParameter","getQualityForBitrate","V","diff1","temp","abs","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"L2ARule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2020, Unified Streaming.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n\nconst L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\nconst L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\nconst L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\n\nfunction L2ARule(config) {\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        l2AStateDict,\n        l2AParameterDict,\n        logger;\n\n    /**\n     * Setup function to initialize L2ARule\n     */\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    /**\n     * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n     * @param {object} rulesContext\n     * @return {object} initialState\n     * @private\n     */\n    function _getInitialL2AState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map((b) => {\n            return b.bandwidth / 1000;\n        });\n\n        initialState.state = L2A_STATE_STARTUP;\n        initialState.bitrates = bitrates;\n        initialState.lastQuality = 0;\n\n        _initializeL2AParameters(mediaInfo);\n        _clearL2AStateOnSeek(initialState);\n\n        return initialState;\n    }\n\n    /**\n     * Initializes the parameters of the algorithm. This will be done once for each media type.\n     * @param {object} mediaInfo\n     * @private\n     */\n    function _initializeL2AParameters(mediaInfo) {\n\n        if (!mediaInfo || !mediaInfo.type) {\n            return;\n        }\n\n        l2AParameterDict[mediaInfo.type] = {};\n        l2AParameterDict[mediaInfo.type].w = [];//Vector of probabilities associated with bitrate decisions\n        l2AParameterDict[mediaInfo.type].prev_w = [];//Vector of probabilities associated with bitrate decisions calculated in the previous step\n        l2AParameterDict[mediaInfo.type].Q = 0;//Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n        l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n        l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n        l2AParameterDict[mediaInfo.type].B_target = 1.5;//Target buffer level\n    }\n\n\n    /**\n     * Clears the state object\n     * @param {object} l2AState\n     * @private\n     */\n    function _clearL2AStateOnSeek(l2AState) {\n        l2AState.placeholderBuffer = 0;\n        l2AState.mostAdvancedSegmentStart = NaN;\n        l2AState.lastSegmentWasReplacement = false;\n        l2AState.lastSegmentStart = NaN;\n        l2AState.lastSegmentDurationS = NaN;\n        l2AState.lastSegmentRequestTimeMs = NaN;\n        l2AState.lastSegmentFinishTimeMs = NaN;\n    }\n\n\n    /**\n     * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n     * @param {object} rulesContext\n     * @return {object} l2AState\n     * @private\n     */\n    function _getL2AState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let l2AState = l2AStateDict[mediaType];\n\n        if (!l2AState) {\n            l2AState = _getInitialL2AState(rulesContext);\n            l2AStateDict[mediaType] = l2AState;\n        }\n\n        return l2AState;\n    }\n\n    /**\n     * Event handler for the seeking event.\n     * @private\n     */\n    function _onPlaybackSeeking() {\n        for (const mediaType in l2AStateDict) {\n            if (l2AStateDict.hasOwnProperty(mediaType)) {\n                const l2aState = l2AStateDict[mediaType];\n                if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n                    l2aState.state = L2A_STATE_STARTUP;\n                    _clearL2AStateOnSeek(l2aState);\n                }\n            }\n        }\n    }\n\n    /**\n     * Event handler for the mediaFragmentLoaded event\n     * @param {object} e\n     * @private\n     */\n    function _onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n            const l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n                    l2AState.mostAdvancedSegmentStart = start;\n                    l2AState.lastSegmentWasReplacement = false;\n                } else {\n                    l2AState.lastSegmentWasReplacement = true;\n                }\n\n                l2AState.lastSegmentStart = start;\n                l2AState.lastSegmentDurationS = e.chunk.duration;\n                l2AState.lastQuality = e.chunk.quality;\n\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * Event handler for the metricAdded event\n     * @param {object} e\n     * @private\n     */\n    function _onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const l2AState = l2AStateDict[e.mediaType];\n            const l2AParameters = l2AParameterDict[e.mediaType];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n     * @param {object} L2AState\n     * @param {object} l2AParameters\n     * @private\n     */\n    function _checkNewSegment(L2AState, l2AParameters) {\n        if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n            l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n            l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n            L2AState.lastSegmentStart = NaN;\n            L2AState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    /**\n     * Event handler for the qualityChangeRequested event\n     * @param {object} e\n     * @private\n     */\n    function _onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e && e.mediaType) {\n            const L2AState = l2AStateDict[e.mediaType];\n            if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n                L2AState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    /**\n     * Calculates the index of the minimum value of an array\n     * @param {array} arr\n     * @return {number} minIndex\n     * @private\n     */\n    function _indexOfMin(arr) {\n        if (arr.length === 0) {\n            return -1;\n        }\n        let min = arr[0];\n        let minIndex = 0;\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] <= min) {\n                minIndex = i;\n                min = arr[i];\n            }\n        }\n        return minIndex;\n    }\n\n    /**\n     * Dot multiplication of two arrays\n     * @param {array} arr1\n     * @param {array} arr2\n     * @return {number} sumdot\n     * @private\n     */\n    function _dotmultiplication(arr1, arr2) {\n        if (arr1.length !== arr2.length) {\n            return -1;\n        }\n        let sumdot = 0;\n        for (let i = 0; i < arr1.length; i++) {\n            sumdot = sumdot + arr1[i] * arr2[i];\n        }\n        return sumdot;\n    }\n\n    /**\n     * Project an n-dim vector y to the simplex Dn\n     * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n     * Algorithm is explained at http://arxiv.org/abs/1101.6081\n     * @param {array} arr\n     * @return {array}\n     * @constructor\n     */\n    function euclideanProjection(arr) {\n        const m = arr.length;\n        let bget = false;\n        let arr2 = [];\n        for (let ii = 0; ii < m; ++ii) {\n            arr2[ii] = arr[ii];\n        }\n        let s = arr.sort(function (a, b) {\n            return b - a;\n        });\n        let tmpsum = 0;\n        let tmax = 0;\n        let x = [];\n        for (let ii = 0; ii < m - 1; ++ii) {\n            tmpsum = tmpsum + s[ii];\n            tmax = (tmpsum - 1) / (ii + 1);\n            if (tmax >= s[ii + 1]) {\n                bget = true;\n                break;\n            }\n        }\n        if (!bget) {\n            tmax = (tmpsum + s[m - 1] - 1) / m;\n        }\n        for (let ii = 0; ii < m; ++ii) {\n            x[ii] = Math.max(arr2[ii] - tmax, 0);\n        }\n        return x;\n    }\n\n    /**\n     * Returns a switch request object indicating which quality is to be played\n     * @param {object} rulesContext\n     * @return {object}\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n        const horizon = 8;//Optimization horizon\n        const vl = Math.pow(horizon, 0.2);//Cautiousness parameter\n        const alpha = Math.max(Math.pow(horizon, 0.7), vl * Math.sqrt(horizon));//Step size\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        const bitrateCount = bitrates.length;\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useL2AABR = rulesContext.useL2AABR();\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const cThroughput = throughput / 1000; //Throughput in Mbps\n        const react = 20;///Reactiveness to throughput drops\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n            return switchRequest;\n        }\n\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useL2AABR) {\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const l2AState = _getL2AState(rulesContext);\n        if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const l2AParameter = l2AParameterDict[mediaType];\n        if (!l2AParameter) {\n            return switchRequest;\n        }\n\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n        if (isNaN(throughput)) {\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (l2AState.state) {\n            case L2A_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n                l2AState.lastQuality = quality;\n                if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AState.lastSegmentDurationS) {\n                    l2AState.state = L2A_STATE_STEADY;\n                }\n                break; // L2A_STATE_STARTUP\n            case L2A_STATE_STEADY:\n                /////////////////////////////Main adaptation logic of L2A-LL\n                let V = l2AState.lastSegmentDurationS;\n                let diff1 = [];//Used to calculate the difference between consecutive decisions (w-w_prev)\n                if (l2AParameter.w.length === 0) {//Initialization of w and w_prev\n                    l2AParameter.Q = 0;\n                    for (let i = 0; i < bitrateCount; ++i) {\n                        if (i === 0) {\n                            l2AParameter.w[i] = 0.33;\n                            l2AParameter.prev_w[i] = 1;\n                        } else {\n                            l2AParameter.w[i] = 0.33;\n                            l2AParameter.prev_w[i] = 0;\n                        }\n                    }\n                }\n                for (let i = 0; i < bitrateCount; ++i) {\n                    bitrates[i] = bitrates[i] / (1000 * 1000);   //Bitrates in Mbps\n                    l2AParameter.w[i] = l2AParameter.prev_w[i] - (1 / (2 * alpha)) * (V * bitrates[i]) * ((l2AParameter.Q - vl) / Math.min(2 * bitrates[bitrateCount - 1], cThroughput));//Lagrangian descent\n                    diff1[i] = l2AParameter.w[i] - l2AParameter.prev_w[i];\n                }\n                l2AParameter.w = euclideanProjection(l2AParameter.w);\n                if (bitrates[l2AState.lastQuality] > ((bitrates[l2AState.lastQuality] * V / (l2AParameter.segment_download_finish_s - l2AParameter.segment_request_start_s)))) {\n                    if (l2AParameter.Q < vl) {\n                        l2AParameter.Q = horizon * vl * react;\n                    }\n                }//Reset Lagrangian multiplier (Q) to speed up potential bitrate switch based on previous throughput measurement\n                l2AParameter.Q = Math.max(0, l2AParameter.Q + V * _dotmultiplication(bitrates, l2AParameter.prev_w) / Math.min(2 * bitrates[bitrateCount - 1], cThroughput) - (react / 2) * V + V * (_dotmultiplication(bitrates, diff1) / Math.min(2 * bitrates[bitrateCount - 1], cThroughput)));\n                let temp = [];\n                for (let i = 0; i < bitrateCount; ++i) {\n                    l2AParameter.prev_w[i] = l2AParameter.w[i];\n                    temp[i] = Math.abs(bitrates[i] - _dotmultiplication(l2AParameter.w, bitrates));\n                }//// Quality is calculated as argmin of the aboslute differnce between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)). We employ a stepwise ascent/descent\n                if (_indexOfMin(temp) > l2AState.lastQuality) {\n                    quality = l2AState.lastQuality + 1;\n                } else if (_indexOfMin(temp) < l2AState.lastQuality) {\n                    quality = l2AState.lastQuality - 1;\n                } else {\n                    quality = _indexOfMin(temp);\n                }\n                /// Provision againts over-estimation.\n                if ((bitrates[quality] >= cThroughput) && (bufferLevel < l2AParameter.B_target)) {\n                    quality = l2AState.lastQuality;\n                }\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                l2AState.lastQuality = quality;\n                break; // L2A_STATE_STEADY\n            default:\n                logger.debug('L2A ABR rule invoked in bad state.');// should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = l2AState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                l2AState.state = L2A_STATE_STARTUP;\n                _clearL2AStateOnSeek(l2AState);\n        }\n        return switchRequest;\n    }\n\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        l2AStateDict = {};\n        l2AParameterDict = {};\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexport default FactoryMaker.getClassFactory(L2ARule);\n"]}